"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureApp = configureApp;
exports.downloadApp = downloadApp;
exports.downloadFile = downloadFile;
exports.copyLocalZip = copyLocalZip;
exports.unzipApp = unzipApp;
exports.unzipFile = unzipFile;
exports.testZipArchive = testZipArchive;
exports.isPackageOrBundle = isPackageOrBundle;
exports.getCoordDefault = getCoordDefault;
exports.getSwipeTouchDuration = getSwipeTouchDuration;
exports.copyFromWindowsNetworkShare = copyFromWindowsNetworkShare;
exports.renameKey = renameKey;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _logger = _interopRequireDefault(require("./logger"));

var _fs2 = _interopRequireDefault(require("fs"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _teen_process = require("teen_process");

var _request = _interopRequireDefault(require("request"));

const ZIP_EXTS = ['.zip', '.ipa'];
const ZIP_MIME_TYPE = 'application/zip';
const DOWNLOADS_CACHE = {};

function getModificationDate(_x) {
  return _getModificationDate.apply(this, arguments);
}

function _getModificationDate() {
  _getModificationDate = (0, _asyncToGenerator2.default)(function* (url) {
    let response;

    try {
      response = yield _request.default.head(url);
    } catch (e) {
      _logger.default.debug(`Cannot send HEAD request to '${url}'. Original error: ${e.message}`);

      return null;
    }

    const value = response.headers['last-modified'];

    _logger.default.debug(`Got '${value}' as 'Last-Modified' HEAD response header value of '${url}'`);

    return value ? new Date(value) : null;
  });
  return _getModificationDate.apply(this, arguments);
}

function getCachedApplicationPath(_x2) {
  return _getCachedApplicationPath.apply(this, arguments);
}

function _getCachedApplicationPath() {
  _getCachedApplicationPath = (0, _asyncToGenerator2.default)(function* (url) {
    const appInfo = DOWNLOADS_CACHE[url];

    if (!appInfo) {
      return null;
    }

    const lastModified = appInfo.lastModified,
          fullPath = appInfo.fullPath;
    const currentModified = yield getModificationDate(url);

    if (!currentModified) {
      return null;
    }

    if (currentModified <= lastModified) {
      _logger.default.debug(`'Last-Modified' response header value of '${url}' is less or equal in comparison to the ` + `cached value '${lastModified}'`);

      return fullPath;
    }

    _logger.default.debug(`'Last-Modified' response header value of '${url}' is greater in comparison to the ` + `cached value '${lastModified}'`);

    return null;
  });
  return _getCachedApplicationPath.apply(this, arguments);
}

function configureApp(_x3, _x4) {
  return _configureApp.apply(this, arguments);
}

function _configureApp() {
  _configureApp = (0, _asyncToGenerator2.default)(function* (app, appExt, mountRoot = "Volumes", windowsShareUserName = "", windowsSharePassword = "") {
    if (!_lodash.default.isString(app)) {
      return;
    }

    let newApp = app;
    let shouldUnzipApp = false;

    const _url$parse = _url.default.parse(newApp),
          protocol = _url$parse.protocol;

    const isUrl = ['http:', 'https:'].includes(protocol);

    if (newApp.startsWith('\\\\')) {
      _logger.default.info(`Downloading the application '${newApp}' from SMB share...`);

      newApp = yield copyFromWindowsNetworkShare(newApp, appExt, mountRoot, windowsShareUserName, windowsSharePassword);

      if (!(yield _appiumSupport.fs.exists(newApp))) {
        throw new Error(`The application at '${app}' does not exist or is not accessible for download`);
      }

      _logger.default.info(`Downloaded the app to '${newApp}'`);
    } else if (isUrl) {
      const cachedPath = yield getCachedApplicationPath(newApp);

      if (cachedPath) {
        if (yield _appiumSupport.fs.exists(cachedPath)) {
          _logger.default.info(`Reusing the previously downloaded application at '${cachedPath}'`);

          return cachedPath;
        }

        _logger.default.info(`The application at '${cachedPath}' does not exist anymore. Deleting it from the cache`);

        delete DOWNLOADS_CACHE[newApp];
      }

      _logger.default.info(`Using downloadable app '${newApp}'`);

      const _ref = yield downloadApp(newApp, appExt),
            targetPath = _ref.targetPath,
            contentType = _ref.contentType;

      newApp = targetPath;
      shouldUnzipApp = _lodash.default.includes(ZIP_EXTS, _path.default.extname(newApp)) || contentType === ZIP_MIME_TYPE;

      _logger.default.info(`Downloaded the app to '${newApp}'`);
    } else if (yield _appiumSupport.fs.exists(newApp)) {
      _logger.default.info(`Using local app '${newApp}'`);

      shouldUnzipApp = _lodash.default.includes(ZIP_EXTS, _path.default.extname(newApp));
      newApp = shouldUnzipApp ? yield copyLocalZip(newApp) : newApp;
    } else {
      let errorMessage = `The application at '${newApp}' does not exist or is not accessible`;

      if (_lodash.default.isString(protocol) && protocol.length > 2) {
        errorMessage = `The protocol '${protocol}' used in '${newApp}' is not supported. ` + `Only http: and https: protocols are supported`;
      }

      throw new Error(errorMessage);
    }

    if (shouldUnzipApp) {
      _logger.default.info(`Unzipping local app '${newApp}'...`);

      const archivePath = newApp;

      try {
        newApp = yield unzipApp(archivePath, appExt);
      } finally {
        yield _appiumSupport.fs.rimraf(archivePath);
      }

      _logger.default.info(`Unzipped local app to '${newApp}'`);
    }

    if (_path.default.extname(newApp) !== appExt) {
      if (newApp !== app) {
        yield _appiumSupport.fs.rimraf(newApp);
      }

      throw new Error(`New app path '${newApp}' did not have extension '${appExt}'`);
    }

    if (isUrl) {
      const lastModified = yield getModificationDate(app);

      if (lastModified) {
        DOWNLOADS_CACHE[_url.default] = {
          lastModified,
          fullPath: newApp
        };
      } else {
        _logger.default.info(`Skipping '${app}' caching, because the HEAD response didn't return` + ` any valid Last-Modified headers`);
      }
    }

    return newApp;
  });
  return _configureApp.apply(this, arguments);
}

function downloadApp(_x5, _x6) {
  return _downloadApp.apply(this, arguments);
}

function _downloadApp() {
  _downloadApp = (0, _asyncToGenerator2.default)(function* (app, appExt) {
    let appUrl;

    try {
      appUrl = _url.default.parse(app);
    } catch (err) {
      throw new Error(`Invalid App URL (${app})`);
    }

    let isZipFile = _lodash.default.includes(ZIP_EXTS, _path.default.extname(appUrl.pathname));

    appExt = isZipFile ? '.zip' : appExt;
    let downloadedApp;

    try {
      downloadedApp = yield downloadFile(_url.default.format(appUrl), appExt);
    } catch (err) {
      throw new Error(`Problem downloading app from url ${app}: ${err}`);
    }

    return downloadedApp;
  });
  return _downloadApp.apply(this, arguments);
}

function downloadFile(_x7, _x8) {
  return _downloadFile.apply(this, arguments);
}

function _downloadFile() {
  _downloadFile = (0, _asyncToGenerator2.default)(function* (sourceUrl, suffix) {
    let targetPath = yield _appiumSupport.tempDir.path({
      prefix: 'appium-app',
      suffix
    });
    let contentType;
    yield new _bluebird.default((resolve, reject) => {
      (0, _request.default)(sourceUrl).on('error', reject).on('response', function (res) {
        if (res.statusCode >= 400) {
          return reject(`Error downloading file: ${res.statusCode}`);
        }

        contentType = res.headers['content-type'];
      }).pipe(_fs2.default.createWriteStream(targetPath)).on('error', reject).on('close', resolve);
    });

    _logger.default.debug(`'${sourceUrl}' downloaded to '${targetPath}'`);

    _logger.default.debug(`Downloaded file type '${contentType}'`);

    return {
      targetPath,
      contentType
    };
  });
  return _downloadFile.apply(this, arguments);
}

function copyLocalZip(_x9) {
  return _copyLocalZip.apply(this, arguments);
}

function _copyLocalZip() {
  _copyLocalZip = (0, _asyncToGenerator2.default)(function* (localZipPath) {
    _logger.default.debug('Copying local zip to tmp dir');

    if (!(yield _appiumSupport.fs.exists(localZipPath))) {
      throw new Error('Local zip did not exist');
    }

    let fileInfo = yield _appiumSupport.tempDir.open({
      prefix: 'appium-app',
      suffix: '.zip'
    });

    let infile = _fs2.default.createReadStream(localZipPath);

    let outfile = _fs2.default.createWriteStream(fileInfo.path);

    return new _bluebird.default((resolve, reject) => {
      infile.pipe(outfile).on('close', () => {
        resolve(fileInfo.path);
      }).on('error', err => {
        reject(err);
      });
    });
  });
  return _copyLocalZip.apply(this, arguments);
}

function unzipApp(_x10, _x11) {
  return _unzipApp.apply(this, arguments);
}

function _unzipApp() {
  _unzipApp = (0, _asyncToGenerator2.default)(function* (zipPath, appExt) {
    let _ref2 = yield (0, _teen_process.exec)('find', [_path.default.dirname(zipPath), '-type', 'd', '-name', `*${appExt}`]),
        stdout = _ref2.stdout;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = stdout.trim().split('\n').filter(Boolean)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        let line = _step.value;
        yield _appiumSupport.fs.rimraf(line);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    yield _appiumSupport.fs.rimraf(_path.default.resolve(_path.default.dirname(zipPath), 'Payload*'));
    let output = yield unzipFile(zipPath);
    let relaxedRegStr = `(?:creating|inflating|extracting): (.+${appExt})/?`;
    let strictReg = new RegExp(`${relaxedRegStr}$`, 'm');
    let relaxedReg = new RegExp(relaxedRegStr, 'm');
    let strictMatch = strictReg.exec(output);
    let relaxedMatch = relaxedReg.exec(output);

    let getAppPath = function getAppPath(match) {
      return _path.default.resolve(_path.default.dirname(zipPath), match[1]);
    };

    if (strictMatch) {
      return getAppPath(strictMatch);
    }

    if (relaxedMatch) {
      _logger.default.debug('Got a relaxed match for app in zip, be careful for app match errors');

      return getAppPath(relaxedMatch);
    }

    throw new Error(`App zip unzipped OK, but we could not find a ${appExt} bundle ` + `in it. Make sure your archive contains the ${appExt} package ` + `and nothing else`);
  });
  return _unzipApp.apply(this, arguments);
}

function unzipFile(_x12) {
  return _unzipFile.apply(this, arguments);
}

function _unzipFile() {
  _unzipFile = (0, _asyncToGenerator2.default)(function* (zipPath) {
    _logger.default.debug(`Unzipping ${zipPath}`);

    let valid = yield testZipArchive(zipPath);

    if (!valid) {
      throw new Error(`Zip archive ${zipPath} did not test valid`);
    }

    if (_appiumSupport.system.isWindows()) {
      yield _appiumSupport.zip.extractAllTo(zipPath, _path.default.dirname(zipPath));

      _logger.default.debug('Unzip successful');

      return;
    }

    let execEnv = _lodash.default.clone(process.env);

    delete execEnv.UNZIP;
    let execOpts = {
      cwd: _path.default.dirname(zipPath),
      env: execEnv
    };

    try {
      let _ref3 = yield (0, _teen_process.exec)('unzip', ['-o', zipPath], execOpts),
          stdout = _ref3.stdout;

      return stdout;
    } catch (err) {
      _logger.default.error(`Unzip threw error ${err}`);

      _logger.default.error(`Stderr: ${err.stderr}`);

      _logger.default.error(`Stdout: ${err.stdout}`);

      throw new Error('Archive could not be unzipped, check appium logs.');
    }
  });
  return _unzipFile.apply(this, arguments);
}

function testZipArchive(_x13) {
  return _testZipArchive.apply(this, arguments);
}

function _testZipArchive() {
  _testZipArchive = (0, _asyncToGenerator2.default)(function* (zipPath) {
    _logger.default.debug(`Testing zip archive: ${zipPath}`);

    if (_appiumSupport.system.isWindows()) {
      if (yield _appiumSupport.fs.exists(zipPath)) {
        _logger.default.debug('Zip archive tested clean');

        return true;
      } else {
        _logger.default.debug('Zip archive not found');

        return false;
      }
    }

    let execEnv = _lodash.default.clone(process.env);

    delete execEnv.UNZIP;
    let execOpts = {
      cwd: _path.default.dirname(zipPath),
      env: execEnv
    };
    let output;

    try {
      output = yield (0, _teen_process.exec)('unzip', ['-tq', zipPath], execOpts);

      if (/No errors detected/.exec(output.stdout)) {
        return true;
      }

      _logger.default.error(`Zip file ${zipPath} was not valid`);

      _logger.default.error(`Stderr: ${output.stderr}`);

      _logger.default.error(`Stdout: ${output.stdout}`);

      _logger.default.error('Zip archive did not test successfully, check appium server ' + 'logs for output');

      return false;
    } catch (err) {
      _logger.default.error(`Test zip archive threw error ${err}`);

      _logger.default.error(`Stderr: ${err.stderr}`);

      _logger.default.error(`Stdout: ${err.stdout}`);

      throw new Error('Error testing zip archive, are you sure this is a zip file?');
    }
  });
  return _testZipArchive.apply(this, arguments);
}

function copyFromWindowsNetworkShare(_x14, _x15, _x16, _x17, _x18) {
  return _copyFromWindowsNetworkShare.apply(this, arguments);
}

function _copyFromWindowsNetworkShare() {
  _copyFromWindowsNetworkShare = (0, _asyncToGenerator2.default)(function* (app, appExt, mountRoot, windowsUserName, windowsPassword) {
    if (_appiumSupport.system.isWindows()) {
      return yield copyLocallyFromWindowsShare(app, appExt);
    } else {
      return yield mountWindowsShareOnMac(app, mountRoot, windowsUserName, windowsPassword);
    }
  });
  return _copyFromWindowsNetworkShare.apply(this, arguments);
}

function mountWindowsShareOnMac(_x19, _x20, _x21, _x22) {
  return _mountWindowsShareOnMac.apply(this, arguments);
}

function _mountWindowsShareOnMac() {
  _mountWindowsShareOnMac = (0, _asyncToGenerator2.default)(function* (app, mountRoot, windowsUserName, windowsPassword) {
    let pathSplit = app.split("\\");
    let networkShare = pathSplit[2];
    let rootFolder = pathSplit[3];
    app = app.replace(/\\/g, "/");
    app = app.replace(`/${networkShare}`, mountRoot);
    let mountPath = `/${mountRoot}/${rootFolder}`;

    let mountNetworkShare = function () {
      var _ref4 = (0, _asyncToGenerator2.default)(function* () {
        yield _appiumSupport.fs.mkdir(mountPath);
        let mountArgs = [`-t`, `smbfs`, `//${windowsUserName}:${windowsPassword}@${networkShare}/${rootFolder}`, mountPath];

        try {
          yield (0, _teen_process.exec)('mount', mountArgs);
        } catch (err) {
          _logger.default.errorAndThrow(`Error mounting: ${err.message}`);
        }
      });

      return function mountNetworkShare() {
        return _ref4.apply(this, arguments);
      };
    }();

    if (yield _appiumSupport.fs.exists(mountPath)) {
      if (yield _appiumSupport.fs.exists(app)) {
        return app;
      }

      let umountArgs = [mountPath];

      try {
        yield (0, _teen_process.exec)('umount', umountArgs);
      } catch (err) {
        _logger.default.error(`Error Unmounting :${err.message}`);
      }

      yield _appiumSupport.fs.rimraf(mountRoot);
    }

    yield mountNetworkShare();
    return app;
  });
  return _mountWindowsShareOnMac.apply(this, arguments);
}

function copyLocallyFromWindowsShare(_x23, _x24) {
  return _copyLocallyFromWindowsShare.apply(this, arguments);
}

function _copyLocallyFromWindowsShare() {
  _copyLocallyFromWindowsShare = (0, _asyncToGenerator2.default)(function* (app, appExt) {
    let fileInfo = yield _appiumSupport.tempDir.open({
      prefix: 'appium-app',
      suffix: appExt
    });
    return yield _appiumSupport.fs.copyFile(app, fileInfo.path);
  });
  return _copyLocallyFromWindowsShare.apply(this, arguments);
}

function isPackageOrBundle(app) {
  return /^([a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)+$/.test(app);
}

function getCoordDefault(val) {
  return _appiumSupport.util.hasValue(val) ? val : 0.5;
}

function getSwipeTouchDuration(waitGesture) {
  let duration = 0.8;

  if (typeof waitGesture.options.ms !== 'undefined' && waitGesture.options.ms) {
    duration = waitGesture.options.ms / 1000;

    if (duration === 0) {
      duration = 0.1;
    }
  }

  return duration;
}

function renameKey(input, inKey, outKey) {
  if (_lodash.default.isArray(input)) {
    return input.map(item => renameKey(item, inKey, outKey));
  } else if (_lodash.default.isPlainObject(input)) {
    return _lodash.default.reduce(input, (resultObj, value, key) => (0, _objectSpread2.default)({}, resultObj, {
      [key === inKey ? outKey : key]: renameKey(value, inKey, outKey)
    }), {});
  }

  return input;
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2hlbHBlcnMuanMiXSwibmFtZXMiOlsiWklQX0VYVFMiLCJaSVBfTUlNRV9UWVBFIiwiRE9XTkxPQURTX0NBQ0hFIiwiZ2V0TW9kaWZpY2F0aW9uRGF0ZSIsInVybCIsInJlc3BvbnNlIiwicmVxdWVzdCIsImhlYWQiLCJlIiwibG9nZ2VyIiwiZGVidWciLCJtZXNzYWdlIiwidmFsdWUiLCJoZWFkZXJzIiwiRGF0ZSIsImdldENhY2hlZEFwcGxpY2F0aW9uUGF0aCIsImFwcEluZm8iLCJsYXN0TW9kaWZpZWQiLCJmdWxsUGF0aCIsImN1cnJlbnRNb2RpZmllZCIsImNvbmZpZ3VyZUFwcCIsImFwcCIsImFwcEV4dCIsIm1vdW50Um9vdCIsIndpbmRvd3NTaGFyZVVzZXJOYW1lIiwid2luZG93c1NoYXJlUGFzc3dvcmQiLCJfIiwiaXNTdHJpbmciLCJuZXdBcHAiLCJzaG91bGRVbnppcEFwcCIsInBhcnNlIiwicHJvdG9jb2wiLCJpc1VybCIsImluY2x1ZGVzIiwic3RhcnRzV2l0aCIsImluZm8iLCJjb3B5RnJvbVdpbmRvd3NOZXR3b3JrU2hhcmUiLCJmcyIsImV4aXN0cyIsIkVycm9yIiwiY2FjaGVkUGF0aCIsImRvd25sb2FkQXBwIiwidGFyZ2V0UGF0aCIsImNvbnRlbnRUeXBlIiwicGF0aCIsImV4dG5hbWUiLCJjb3B5TG9jYWxaaXAiLCJlcnJvck1lc3NhZ2UiLCJsZW5ndGgiLCJhcmNoaXZlUGF0aCIsInVuemlwQXBwIiwicmltcmFmIiwiYXBwVXJsIiwiZXJyIiwiaXNaaXBGaWxlIiwicGF0aG5hbWUiLCJkb3dubG9hZGVkQXBwIiwiZG93bmxvYWRGaWxlIiwiZm9ybWF0Iiwic291cmNlVXJsIiwic3VmZml4IiwidGVtcERpciIsInByZWZpeCIsIkIiLCJyZXNvbHZlIiwicmVqZWN0Iiwib24iLCJyZXMiLCJzdGF0dXNDb2RlIiwicGlwZSIsIl9mcyIsImNyZWF0ZVdyaXRlU3RyZWFtIiwibG9jYWxaaXBQYXRoIiwiZmlsZUluZm8iLCJvcGVuIiwiaW5maWxlIiwiY3JlYXRlUmVhZFN0cmVhbSIsIm91dGZpbGUiLCJ6aXBQYXRoIiwiZGlybmFtZSIsInN0ZG91dCIsInRyaW0iLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJsaW5lIiwib3V0cHV0IiwidW56aXBGaWxlIiwicmVsYXhlZFJlZ1N0ciIsInN0cmljdFJlZyIsIlJlZ0V4cCIsInJlbGF4ZWRSZWciLCJzdHJpY3RNYXRjaCIsImV4ZWMiLCJyZWxheGVkTWF0Y2giLCJnZXRBcHBQYXRoIiwibWF0Y2giLCJ2YWxpZCIsInRlc3RaaXBBcmNoaXZlIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiemlwIiwiZXh0cmFjdEFsbFRvIiwiZXhlY0VudiIsImNsb25lIiwicHJvY2VzcyIsImVudiIsIlVOWklQIiwiZXhlY09wdHMiLCJjd2QiLCJlcnJvciIsInN0ZGVyciIsIndpbmRvd3NVc2VyTmFtZSIsIndpbmRvd3NQYXNzd29yZCIsImNvcHlMb2NhbGx5RnJvbVdpbmRvd3NTaGFyZSIsIm1vdW50V2luZG93c1NoYXJlT25NYWMiLCJwYXRoU3BsaXQiLCJuZXR3b3JrU2hhcmUiLCJyb290Rm9sZGVyIiwicmVwbGFjZSIsIm1vdW50UGF0aCIsIm1vdW50TmV0d29ya1NoYXJlIiwibWtkaXIiLCJtb3VudEFyZ3MiLCJlcnJvckFuZFRocm93IiwidW1vdW50QXJncyIsImNvcHlGaWxlIiwiaXNQYWNrYWdlT3JCdW5kbGUiLCJ0ZXN0IiwiZ2V0Q29vcmREZWZhdWx0IiwidmFsIiwidXRpbCIsImhhc1ZhbHVlIiwiZ2V0U3dpcGVUb3VjaER1cmF0aW9uIiwid2FpdEdlc3R1cmUiLCJkdXJhdGlvbiIsIm9wdGlvbnMiLCJtcyIsInJlbmFtZUtleSIsImlucHV0IiwiaW5LZXkiLCJvdXRLZXkiLCJpc0FycmF5IiwibWFwIiwiaXRlbSIsImlzUGxhaW5PYmplY3QiLCJyZWR1Y2UiLCJyZXN1bHRPYmoiLCJrZXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztB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LE1BQWQsQ0FBN0IsQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJbkgsZ0JBQUV1SCxhQUFGLENBQWdCTixLQUFoQixDQUFKLEVBQTRCO0FBQ2pDLFdBQU9qSCxnQkFBRXdILE1BQUYsQ0FBU1AsS0FBVCxFQUFnQixDQUFDUSxTQUFELEVBQVl2SSxLQUFaLEVBQW1Cd0ksR0FBbkIscUNBQ2xCRCxTQURrQjtBQUVyQixPQUFDQyxHQUFHLEtBQUtSLEtBQVIsR0FBZ0JDLE1BQWhCLEdBQXlCTyxHQUExQixHQUFnQ1YsU0FBUyxDQUFDOUgsS0FBRCxFQUFRZ0ksS0FBUixFQUFlQyxNQUFmO0FBRnBCLE1BQWhCLEVBR0gsRUFIRyxDQUFQO0FBSUQ7O0FBRUQsU0FBT0YsS0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgX2ZzIGZyb20gJ2ZzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHRlbXBEaXIsIHN5c3RlbSwgZnMsIHV0aWwsIHppcCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSAncmVxdWVzdCc7XG5cbmNvbnN0IFpJUF9FWFRTID0gWycuemlwJywgJy5pcGEnXTtcbmNvbnN0IFpJUF9NSU1FX1RZUEUgPSAnYXBwbGljYXRpb24vemlwJztcbmNvbnN0IERPV05MT0FEU19DQUNIRSA9IHt9O1xuXG5hc3luYyBmdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlICh1cmwpIHtcbiAgbGV0IHJlc3BvbnNlO1xuICB0cnkge1xuICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5oZWFkKHVybCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIuZGVidWcoYENhbm5vdCBzZW5kIEhFQUQgcmVxdWVzdCB0byAnJHt1cmx9Jy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gcmVzcG9uc2UuaGVhZGVyc1snbGFzdC1tb2RpZmllZCddO1xuICBsb2dnZXIuZGVidWcoYEdvdCAnJHt2YWx1ZX0nIGFzICdMYXN0LU1vZGlmaWVkJyBIRUFEIHJlc3BvbnNlIGhlYWRlciB2YWx1ZSBvZiAnJHt1cmx9J2ApO1xuICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRBcHBsaWNhdGlvblBhdGggKHVybCkge1xuICBjb25zdCBhcHBJbmZvID0gRE9XTkxPQURTX0NBQ0hFW3VybF07XG4gIGlmICghYXBwSW5mbykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHtsYXN0TW9kaWZpZWQsIGZ1bGxQYXRofSA9IGFwcEluZm87XG4gIGNvbnN0IGN1cnJlbnRNb2RpZmllZCA9IGF3YWl0IGdldE1vZGlmaWNhdGlvbkRhdGUodXJsKTtcbiAgaWYgKCFjdXJyZW50TW9kaWZpZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY3VycmVudE1vZGlmaWVkIDw9IGxhc3RNb2RpZmllZCkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgJ0xhc3QtTW9kaWZpZWQnIHJlc3BvbnNlIGhlYWRlciB2YWx1ZSBvZiAnJHt1cmx9JyBpcyBsZXNzIG9yIGVxdWFsIGluIGNvbXBhcmlzb24gdG8gdGhlIGAgK1xuICAgICAgICAgICAgICAgICBgY2FjaGVkIHZhbHVlICcke2xhc3RNb2RpZmllZH0nYCk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xuICB9XG4gIGxvZ2dlci5kZWJ1ZyhgJ0xhc3QtTW9kaWZpZWQnIHJlc3BvbnNlIGhlYWRlciB2YWx1ZSBvZiAnJHt1cmx9JyBpcyBncmVhdGVyIGluIGNvbXBhcmlzb24gdG8gdGhlIGAgK1xuICAgICAgICAgICAgICAgYGNhY2hlZCB2YWx1ZSAnJHtsYXN0TW9kaWZpZWR9J2ApO1xuICByZXR1cm4gbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29uZmlndXJlQXBwIChhcHAsIGFwcEV4dCwgbW91bnRSb290ID0gXCJWb2x1bWVzXCIsIHdpbmRvd3NTaGFyZVVzZXJOYW1lID0gXCJcIiwgd2luZG93c1NoYXJlUGFzc3dvcmQgPSBcIlwiKSB7XG4gIGlmICghXy5pc1N0cmluZyhhcHApKSB7XG4gICAgLy8gaW1tZWRpYXRlbHkgc2hvcnRjaXJjdWl0IGlmIG5vdCBnaXZlbiBhbiBhcHBcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbmV3QXBwID0gYXBwO1xuICBsZXQgc2hvdWxkVW56aXBBcHAgPSBmYWxzZTtcbiAgY29uc3Qge3Byb3RvY29sfSA9IHVybC5wYXJzZShuZXdBcHApO1xuICBjb25zdCBpc1VybCA9IFsnaHR0cDonLCAnaHR0cHM6J10uaW5jbHVkZXMocHJvdG9jb2wpO1xuXG4gIGlmIChuZXdBcHAuc3RhcnRzV2l0aCgnXFxcXFxcXFwnKSkge1xuICAgIC8vIFVzZSB0aGUgYXBwIGZyb20gV2luZG93cyBuZXR3b3JrIHNoYXJlXG4gICAgbG9nZ2VyLmluZm8oYERvd25sb2FkaW5nIHRoZSBhcHBsaWNhdGlvbiAnJHtuZXdBcHB9JyBmcm9tIFNNQiBzaGFyZS4uLmApO1xuICAgIG5ld0FwcCA9IGF3YWl0IGNvcHlGcm9tV2luZG93c05ldHdvcmtTaGFyZShuZXdBcHAsIGFwcEV4dCxcbiAgICAgIG1vdW50Um9vdCwgd2luZG93c1NoYXJlVXNlck5hbWUsIHdpbmRvd3NTaGFyZVBhc3N3b3JkKTtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhuZXdBcHApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBhcHBsaWNhdGlvbiBhdCAnJHthcHB9JyBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYWNjZXNzaWJsZSBmb3IgZG93bmxvYWRgKTtcbiAgICB9XG4gICAgbG9nZ2VyLmluZm8oYERvd25sb2FkZWQgdGhlIGFwcCB0byAnJHtuZXdBcHB9J2ApO1xuICB9IGVsc2UgaWYgKGlzVXJsKSB7XG4gICAgLy8gVXNlIHRoZSBhcHAgZnJvbSByZW1vdGUgVVJMXG4gICAgY29uc3QgY2FjaGVkUGF0aCA9IGF3YWl0IGdldENhY2hlZEFwcGxpY2F0aW9uUGF0aChuZXdBcHApO1xuICAgIGlmIChjYWNoZWRQYXRoKSB7XG4gICAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGNhY2hlZFBhdGgpKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBSZXVzaW5nIHRoZSBwcmV2aW91c2x5IGRvd25sb2FkZWQgYXBwbGljYXRpb24gYXQgJyR7Y2FjaGVkUGF0aH0nYCk7XG4gICAgICAgIHJldHVybiBjYWNoZWRQYXRoO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmluZm8oYFRoZSBhcHBsaWNhdGlvbiBhdCAnJHtjYWNoZWRQYXRofScgZG9lcyBub3QgZXhpc3QgYW55bW9yZS4gRGVsZXRpbmcgaXQgZnJvbSB0aGUgY2FjaGVgKTtcbiAgICAgIGRlbGV0ZSBET1dOTE9BRFNfQ0FDSEVbbmV3QXBwXTtcbiAgICB9XG4gICAgbG9nZ2VyLmluZm8oYFVzaW5nIGRvd25sb2FkYWJsZSBhcHAgJyR7bmV3QXBwfSdgKTtcbiAgICBjb25zdCB7dGFyZ2V0UGF0aCwgY29udGVudFR5cGV9ID0gYXdhaXQgZG93bmxvYWRBcHAobmV3QXBwLCBhcHBFeHQpO1xuICAgIG5ld0FwcCA9IHRhcmdldFBhdGg7XG4gICAgLy8gdGhlIGZpbGV0eXBlIG1heSBub3QgYmUgb2J2aW91cyBmb3IgY2VydGFpbiB1cmxzLCBzbyBjaGVjayB0aGUgbWltZSB0eXBlIHRvb1xuICAgIHNob3VsZFVuemlwQXBwID0gXy5pbmNsdWRlcyhaSVBfRVhUUywgcGF0aC5leHRuYW1lKG5ld0FwcCkpIHx8IGNvbnRlbnRUeXBlID09PSBaSVBfTUlNRV9UWVBFO1xuICAgIGxvZ2dlci5pbmZvKGBEb3dubG9hZGVkIHRoZSBhcHAgdG8gJyR7bmV3QXBwfSdgKTtcbiAgfSBlbHNlIGlmIChhd2FpdCBmcy5leGlzdHMobmV3QXBwKSkge1xuICAgIC8vIFVzZSB0aGUgbG9jYWwgYXBwXG4gICAgbG9nZ2VyLmluZm8oYFVzaW5nIGxvY2FsIGFwcCAnJHtuZXdBcHB9J2ApO1xuICAgIHNob3VsZFVuemlwQXBwID0gXy5pbmNsdWRlcyhaSVBfRVhUUywgcGF0aC5leHRuYW1lKG5ld0FwcCkpO1xuICAgIG5ld0FwcCA9IHNob3VsZFVuemlwQXBwID8gYXdhaXQgY29weUxvY2FsWmlwKG5ld0FwcCkgOiBuZXdBcHA7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IGBUaGUgYXBwbGljYXRpb24gYXQgJyR7bmV3QXBwfScgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGFjY2Vzc2libGVgO1xuICAgIC8vIHByb3RvY29sIHZhbHVlIGZvciAnQzpcXFxcdGVtcCcgaXMgJ2M6Jywgc28gd2UgY2hlY2sgdGhlIGxlbmd0aCBhcyB3ZWxsXG4gICAgaWYgKF8uaXNTdHJpbmcocHJvdG9jb2wpICYmIHByb3RvY29sLmxlbmd0aCA+IDIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBUaGUgcHJvdG9jb2wgJyR7cHJvdG9jb2x9JyB1c2VkIGluICcke25ld0FwcH0nIGlzIG5vdCBzdXBwb3J0ZWQuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgYE9ubHkgaHR0cDogYW5kIGh0dHBzOiBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZGA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKHNob3VsZFVuemlwQXBwKSB7XG4gICAgbG9nZ2VyLmluZm8oYFVuemlwcGluZyBsb2NhbCBhcHAgJyR7bmV3QXBwfScuLi5gKTtcbiAgICBjb25zdCBhcmNoaXZlUGF0aCA9IG5ld0FwcDtcbiAgICB0cnkge1xuICAgICAgbmV3QXBwID0gYXdhaXQgdW56aXBBcHAoYXJjaGl2ZVBhdGgsIGFwcEV4dCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGZzLnJpbXJhZihhcmNoaXZlUGF0aCk7XG4gICAgfVxuICAgIGxvZ2dlci5pbmZvKGBVbnppcHBlZCBsb2NhbCBhcHAgdG8gJyR7bmV3QXBwfSdgKTtcbiAgfVxuXG4gIGlmIChwYXRoLmV4dG5hbWUobmV3QXBwKSAhPT0gYXBwRXh0KSB7XG4gICAgaWYgKG5ld0FwcCAhPT0gYXBwKSB7XG4gICAgICBhd2FpdCBmcy5yaW1yYWYobmV3QXBwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOZXcgYXBwIHBhdGggJyR7bmV3QXBwfScgZGlkIG5vdCBoYXZlIGV4dGVuc2lvbiAnJHthcHBFeHR9J2ApO1xuICB9XG5cbiAgaWYgKGlzVXJsKSB7XG4gICAgY29uc3QgbGFzdE1vZGlmaWVkID0gYXdhaXQgZ2V0TW9kaWZpY2F0aW9uRGF0ZShhcHApO1xuICAgIGlmIChsYXN0TW9kaWZpZWQpIHtcbiAgICAgIERPV05MT0FEU19DQUNIRVt1cmxdID0ge1xuICAgICAgICBsYXN0TW9kaWZpZWQsXG4gICAgICAgIGZ1bGxQYXRoOiBuZXdBcHAsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuaW5mbyhgU2tpcHBpbmcgJyR7YXBwfScgY2FjaGluZywgYmVjYXVzZSB0aGUgSEVBRCByZXNwb25zZSBkaWRuJ3QgcmV0dXJuYCArXG4gICAgICAgICAgICAgICAgICBgIGFueSB2YWxpZCBMYXN0LU1vZGlmaWVkIGhlYWRlcnNgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QXBwO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFwcCAoYXBwLCBhcHBFeHQpIHtcbiAgbGV0IGFwcFVybDtcbiAgdHJ5IHtcbiAgICBhcHBVcmwgPSB1cmwucGFyc2UoYXBwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEFwcCBVUkwgKCR7YXBwfSlgKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRoaXMgaXMgemlwcGVkXG4gIGxldCBpc1ppcEZpbGUgPSBfLmluY2x1ZGVzKFpJUF9FWFRTLCBwYXRoLmV4dG5hbWUoYXBwVXJsLnBhdGhuYW1lKSk7XG4gIGFwcEV4dCA9IGlzWmlwRmlsZSA/ICcuemlwJyA6IGFwcEV4dDtcblxuICBsZXQgZG93bmxvYWRlZEFwcDtcbiAgdHJ5IHtcbiAgICBkb3dubG9hZGVkQXBwID0gYXdhaXQgZG93bmxvYWRGaWxlKHVybC5mb3JtYXQoYXBwVXJsKSwgYXBwRXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ibGVtIGRvd25sb2FkaW5nIGFwcCBmcm9tIHVybCAke2FwcH06ICR7ZXJyfWApO1xuICB9XG5cbiAgcmV0dXJuIGRvd25sb2FkZWRBcHA7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZSAoc291cmNlVXJsLCBzdWZmaXgpIHtcbiAgLy8gV2Ugd2lsbCBiZSBkb3dubG9hZGluZyB0aGUgZmlsZXMgdG8gYSBkaXJlY3RvcnksIHNvIG1ha2Ugc3VyZSBpdCdzIHRoZXJlXG4gIC8vIFRoaXMgc3RlcCBpcyBub3QgcmVxdWlyZWQgaWYgeW91IGhhdmUgbWFudWFsbHkgY3JlYXRlZCB0aGUgZGlyZWN0b3J5XG4gIGxldCB0YXJnZXRQYXRoID0gYXdhaXQgdGVtcERpci5wYXRoKHtwcmVmaXg6ICdhcHBpdW0tYXBwJywgc3VmZml4fSk7XG4gIGxldCBjb250ZW50VHlwZTtcblxuICAvLyBkb24ndCB1c2UgcmVxdWVzdC1wcm9taXNlIGhlcmUsIHdlIG5lZWQgc3RyZWFtc1xuICBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVxdWVzdChzb3VyY2VVcmwpXG4gICAgICAub24oJ2Vycm9yJywgcmVqZWN0KSAvLyBoYW5kbGUgcmVhbCBlcnJvcnMsIGxpa2UgY29ubmVjdGlvbiBlcnJvcnNcbiAgICAgIC5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIC8vIGhhbmRsZSByZXNwb25zZXMgdGhhdCBmYWlsLCBsaWtlIDQwNHNcbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoYEVycm9yIGRvd25sb2FkaW5nIGZpbGU6ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudFR5cGUgPSByZXMuaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgICB9KVxuICAgICAgLnBpcGUoX2ZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldFBhdGgpKVxuICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgIC5vbignY2xvc2UnLCByZXNvbHZlKTtcbiAgfSk7XG5cbiAgbG9nZ2VyLmRlYnVnKGAnJHtzb3VyY2VVcmx9JyBkb3dubG9hZGVkIHRvICcke3RhcmdldFBhdGh9J2ApO1xuICBsb2dnZXIuZGVidWcoYERvd25sb2FkZWQgZmlsZSB0eXBlICcke2NvbnRlbnRUeXBlfSdgKTtcbiAgcmV0dXJuIHt0YXJnZXRQYXRoLCBjb250ZW50VHlwZX07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlMb2NhbFppcCAobG9jYWxaaXBQYXRoKSB7XG4gIGxvZ2dlci5kZWJ1ZygnQ29weWluZyBsb2NhbCB6aXAgdG8gdG1wIGRpcicpO1xuICBpZiAoIShhd2FpdCBmcy5leGlzdHMobG9jYWxaaXBQYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIHppcCBkaWQgbm90IGV4aXN0Jyk7XG4gIH1cbiAgbGV0IGZpbGVJbmZvID0gYXdhaXQgdGVtcERpci5vcGVuKHtwcmVmaXg6ICdhcHBpdW0tYXBwJywgc3VmZml4OiAnLnppcCd9KTtcbiAgbGV0IGluZmlsZSA9IF9mcy5jcmVhdGVSZWFkU3RyZWFtKGxvY2FsWmlwUGF0aCk7XG4gIGxldCBvdXRmaWxlID0gX2ZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGVJbmZvLnBhdGgpO1xuICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGluZmlsZS5waXBlKG91dGZpbGUpLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHJlc29sdmUoZmlsZUluZm8ucGF0aCk7XG4gICAgfSkub24oJ2Vycm9yJywgKGVycikgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLWNhbGxiYWNrc1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1bnppcEFwcCAoemlwUGF0aCwgYXBwRXh0KSB7XG4gIC8vIGZpcnN0IGRlbGV0ZSBhbnkgZXhpc3RpbmcgYXBwcyB0aGF0IG1pZ2h0IGJlIGluIG91ciB0bXAgZGlyXG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ2ZpbmQnLCBbcGF0aC5kaXJuYW1lKHppcFBhdGgpLCAnLXR5cGUnLCAnZCcsICctbmFtZScsIGAqJHthcHBFeHR9YF0pO1xuICBmb3IgKGxldCBsaW5lIG9mIHN0ZG91dC50cmltKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKSkge1xuICAgIGF3YWl0IGZzLnJpbXJhZihsaW5lKTtcbiAgfVxuICAvLyBub3cgZGVsZXRlIGFueSBleGlzdGluZyB6aXAgcGF5bG9hZFxuICBhd2FpdCBmcy5yaW1yYWYocGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZSh6aXBQYXRoKSwgJ1BheWxvYWQqJykpO1xuICBsZXQgb3V0cHV0ID0gYXdhaXQgdW56aXBGaWxlKHppcFBhdGgpO1xuICBsZXQgcmVsYXhlZFJlZ1N0ciA9IGAoPzpjcmVhdGluZ3xpbmZsYXRpbmd8ZXh0cmFjdGluZyk6ICguKyR7YXBwRXh0fSkvP2A7XG4gIC8vIGluIHRoZSBzdHJpY3QgcmVnZXgsIHdlIGNoZWNrIGZvciBhbiBlbnRyeSB3aGljaCBlbmRzIHdpdGggdGhlXG4gIC8vIGV4dGVuc2lvblxuICBsZXQgc3RyaWN0UmVnID0gbmV3IFJlZ0V4cChgJHtyZWxheGVkUmVnU3RyfSRgLCAnbScpO1xuICAvLyBvdGhlcndpc2UsIHdlIGFsbG93IGFuIGVudHJ5IHdoaWNoIGNvbnRhaW5zIHRoZSBleHRlbnNpb24sIGJ1dCB3ZVxuICAvLyBuZWVkIHRvIGJlIGNhcmVmdWwsIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmYWxzZSBwb3NpdGl2ZVxuICBsZXQgcmVsYXhlZFJlZyA9IG5ldyBSZWdFeHAocmVsYXhlZFJlZ1N0ciwgJ20nKTtcbiAgbGV0IHN0cmljdE1hdGNoID0gc3RyaWN0UmVnLmV4ZWMob3V0cHV0KTtcbiAgbGV0IHJlbGF4ZWRNYXRjaCA9IHJlbGF4ZWRSZWcuZXhlYyhvdXRwdXQpO1xuICBsZXQgZ2V0QXBwUGF0aCA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHppcFBhdGgpLCBtYXRjaFsxXSk7XG4gIH07XG5cbiAgaWYgKHN0cmljdE1hdGNoKSB7XG4gICAgcmV0dXJuIGdldEFwcFBhdGgoc3RyaWN0TWF0Y2gpO1xuICB9XG5cbiAgaWYgKHJlbGF4ZWRNYXRjaCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnR290IGEgcmVsYXhlZCBtYXRjaCBmb3IgYXBwIGluIHppcCwgYmUgY2FyZWZ1bCBmb3IgYXBwIG1hdGNoIGVycm9ycycpO1xuICAgIHJldHVybiBnZXRBcHBQYXRoKHJlbGF4ZWRNYXRjaCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYEFwcCB6aXAgdW56aXBwZWQgT0ssIGJ1dCB3ZSBjb3VsZCBub3QgZmluZCBhICR7YXBwRXh0fSBidW5kbGUgYCArXG4gICAgICAgICAgICAgICAgICBgaW4gaXQuIE1ha2Ugc3VyZSB5b3VyIGFyY2hpdmUgY29udGFpbnMgdGhlICR7YXBwRXh0fSBwYWNrYWdlIGAgK1xuICAgICAgICAgICAgICAgICAgYGFuZCBub3RoaW5nIGVsc2VgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdW56aXBGaWxlICh6aXBQYXRoKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgVW56aXBwaW5nICR7emlwUGF0aH1gKTtcbiAgbGV0IHZhbGlkID0gYXdhaXQgdGVzdFppcEFyY2hpdmUoemlwUGF0aCk7XG4gIGlmICghdmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFppcCBhcmNoaXZlICR7emlwUGF0aH0gZGlkIG5vdCB0ZXN0IHZhbGlkYCk7XG4gIH1cblxuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgYXdhaXQgemlwLmV4dHJhY3RBbGxUbyh6aXBQYXRoLCBwYXRoLmRpcm5hbWUoemlwUGF0aCkpO1xuICAgIGxvZ2dlci5kZWJ1ZygnVW56aXAgc3VjY2Vzc2Z1bCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBleGVjRW52ID0gXy5jbG9uZShwcm9jZXNzLmVudik7XG4gIGRlbGV0ZSBleGVjRW52LlVOWklQO1xuICBsZXQgZXhlY09wdHMgPSB7Y3dkOiBwYXRoLmRpcm5hbWUoemlwUGF0aCksIGVudjogZXhlY0Vudn07XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygndW56aXAnLCBbJy1vJywgemlwUGF0aF0sIGV4ZWNPcHRzKTtcbiAgICByZXR1cm4gc3Rkb3V0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXIuZXJyb3IoYFVuemlwIHRocmV3IGVycm9yICR7ZXJyfWApO1xuICAgIGxvZ2dlci5lcnJvcihgU3RkZXJyOiAke2Vyci5zdGRlcnJ9YCk7XG4gICAgbG9nZ2VyLmVycm9yKGBTdGRvdXQ6ICR7ZXJyLnN0ZG91dH1gKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyY2hpdmUgY291bGQgbm90IGJlIHVuemlwcGVkLCBjaGVjayBhcHBpdW0gbG9ncy4nKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB0ZXN0WmlwQXJjaGl2ZSAoemlwUGF0aCkge1xuICBsb2dnZXIuZGVidWcoYFRlc3RpbmcgemlwIGFyY2hpdmU6ICR7emlwUGF0aH1gKTtcbiAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMoemlwUGF0aCkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnWmlwIGFyY2hpdmUgdGVzdGVkIGNsZWFuJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdaaXAgYXJjaGl2ZSBub3QgZm91bmQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBsZXQgZXhlY0VudiA9IF8uY2xvbmUocHJvY2Vzcy5lbnYpO1xuICBkZWxldGUgZXhlY0Vudi5VTlpJUDtcbiAgbGV0IGV4ZWNPcHRzID0ge2N3ZDogcGF0aC5kaXJuYW1lKHppcFBhdGgpLCBlbnY6IGV4ZWNFbnZ9O1xuICBsZXQgb3V0cHV0O1xuICB0cnkge1xuICAgIG91dHB1dCA9IGF3YWl0IGV4ZWMoJ3VuemlwJywgWyctdHEnLCB6aXBQYXRoXSwgZXhlY09wdHMpO1xuICAgIGlmICgvTm8gZXJyb3JzIGRldGVjdGVkLy5leGVjKG91dHB1dC5zdGRvdXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbG9nZ2VyLmVycm9yKGBaaXAgZmlsZSAke3ppcFBhdGh9IHdhcyBub3QgdmFsaWRgKTtcbiAgICBsb2dnZXIuZXJyb3IoYFN0ZGVycjogJHtvdXRwdXQuc3RkZXJyfWApO1xuICAgIGxvZ2dlci5lcnJvcihgU3Rkb3V0OiAke291dHB1dC5zdGRvdXR9YCk7XG4gICAgbG9nZ2VyLmVycm9yKCdaaXAgYXJjaGl2ZSBkaWQgbm90IHRlc3Qgc3VjY2Vzc2Z1bGx5LCBjaGVjayBhcHBpdW0gc2VydmVyICcgK1xuICAgICAgICAgICAgICAgICAnbG9ncyBmb3Igb3V0cHV0Jyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXIuZXJyb3IoYFRlc3QgemlwIGFyY2hpdmUgdGhyZXcgZXJyb3IgJHtlcnJ9YCk7XG4gICAgbG9nZ2VyLmVycm9yKGBTdGRlcnI6ICR7ZXJyLnN0ZGVycn1gKTtcbiAgICBsb2dnZXIuZXJyb3IoYFN0ZG91dDogJHtlcnIuc3Rkb3V0fWApO1xuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdGVzdGluZyB6aXAgYXJjaGl2ZSwgYXJlIHlvdSBzdXJlIHRoaXMgaXMgYSB6aXAgZmlsZT8nKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5RnJvbVdpbmRvd3NOZXR3b3JrU2hhcmUgKGFwcCwgYXBwRXh0LCBtb3VudFJvb3QsIHdpbmRvd3NVc2VyTmFtZSwgd2luZG93c1Bhc3N3b3JkKSB7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICByZXR1cm4gYXdhaXQgY29weUxvY2FsbHlGcm9tV2luZG93c1NoYXJlKGFwcCwgYXBwRXh0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgbW91bnRXaW5kb3dzU2hhcmVPbk1hYyhhcHAsIG1vdW50Um9vdCwgd2luZG93c1VzZXJOYW1lLCB3aW5kb3dzUGFzc3dvcmQpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1vdW50V2luZG93c1NoYXJlT25NYWMgKGFwcCwgbW91bnRSb290LCB3aW5kb3dzVXNlck5hbWUsIHdpbmRvd3NQYXNzd29yZCkge1xuICBsZXQgcGF0aFNwbGl0ID0gYXBwLnNwbGl0KFwiXFxcXFwiKTtcbiAgbGV0IG5ldHdvcmtTaGFyZSA9IHBhdGhTcGxpdFsyXTtcbiAgbGV0IHJvb3RGb2xkZXIgPSBwYXRoU3BsaXRbM107XG4gIGFwcCA9IGFwcC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgYXBwID0gYXBwLnJlcGxhY2UoYC8ke25ldHdvcmtTaGFyZX1gLCBtb3VudFJvb3QpO1xuICBsZXQgbW91bnRQYXRoID0gYC8ke21vdW50Um9vdH0vJHtyb290Rm9sZGVyfWA7XG5cbiAgbGV0IG1vdW50TmV0d29ya1NoYXJlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGF3YWl0IGZzLm1rZGlyKG1vdW50UGF0aCk7XG4gICAgbGV0IG1vdW50QXJncyA9IFtgLXRgLCBgc21iZnNgLCBgLy8ke3dpbmRvd3NVc2VyTmFtZX06JHt3aW5kb3dzUGFzc3dvcmR9QCR7bmV0d29ya1NoYXJlfS8ke3Jvb3RGb2xkZXJ9YCwgbW91bnRQYXRoXTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYygnbW91bnQnLCBtb3VudEFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coYEVycm9yIG1vdW50aW5nOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfTtcblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKG1vdW50UGF0aCkpIHtcbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGFwcCkpIHtcbiAgICAgIHJldHVybiBhcHA7XG4gICAgfVxuICAgIGxldCB1bW91bnRBcmdzID0gW21vdW50UGF0aF07XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWMoJ3Vtb3VudCcsIHVtb3VudEFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciBVbm1vdW50aW5nIDoke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBhd2FpdCBmcy5yaW1yYWYobW91bnRSb290KTtcbiAgfVxuICBhd2FpdCBtb3VudE5ldHdvcmtTaGFyZSgpO1xuICByZXR1cm4gYXBwO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5TG9jYWxseUZyb21XaW5kb3dzU2hhcmUgKGFwcCwgYXBwRXh0KSB7XG4gIGxldCBmaWxlSW5mbyA9IGF3YWl0IHRlbXBEaXIub3Blbih7cHJlZml4OiAnYXBwaXVtLWFwcCcsIHN1ZmZpeDogYXBwRXh0fSk7XG4gIHJldHVybiBhd2FpdCBmcy5jb3B5RmlsZShhcHAsIGZpbGVJbmZvLnBhdGgpO1xufVxuXG5mdW5jdGlvbiBpc1BhY2thZ2VPckJ1bmRsZSAoYXBwKSB7XG4gIHJldHVybiAoL14oW2EtekEtWjAtOVxcLV9dK1xcLlthLXpBLVowLTlcXC1fXSspKyQvKS50ZXN0KGFwcCk7XG59XG5cbmZ1bmN0aW9uIGdldENvb3JkRGVmYXVsdCAodmFsKSB7XG4gIC8vIGdvaW5nIHRoZSBsb25nIHdheSBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZCBhbmQgbnVsbCBzaW5jZVxuICAvLyB3ZSBjYW4ndCBiZSBhc3N1cmVkIGBlbElkYCBpcyBhIHN0cmluZyBhbmQgbm90IGFuIGludC4gU2FtZVxuICAvLyB0aGluZyB3aXRoIGRlc3RFbGVtZW50IGJlbG93LlxuICByZXR1cm4gdXRpbC5oYXNWYWx1ZSh2YWwpID8gdmFsIDogMC41O1xufVxuXG5mdW5jdGlvbiBnZXRTd2lwZVRvdWNoRHVyYXRpb24gKHdhaXRHZXN0dXJlKSB7XG4gIC8vIHRoZSB0b3VjaCBhY3Rpb24gYXBpIHVzZXMgbXMsIHdlIHdhbnQgc2Vjb25kc1xuICAvLyAwLjggaXMgdGhlIGRlZmF1bHQgdGltZSBmb3IgdGhlIG9wZXJhdGlvblxuICBsZXQgZHVyYXRpb24gPSAwLjg7XG4gIGlmICh0eXBlb2Ygd2FpdEdlc3R1cmUub3B0aW9ucy5tcyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2FpdEdlc3R1cmUub3B0aW9ucy5tcykge1xuICAgIGR1cmF0aW9uID0gd2FpdEdlc3R1cmUub3B0aW9ucy5tcyAvIDEwMDA7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAvLyBzZXQgdG8gYSB2ZXJ5IGxvdyBudW1iZXIsIHNpbmNlIHRoZXkgd2FudGVkIGl0IGZhc3RcbiAgICAgIC8vIGJ1dCBiZWxvdyAwLjEgYmVjb21lcyAwIHN0ZXBzLCB3aGljaCBjYXVzZXMgZXJyb3JzXG4gICAgICBkdXJhdGlvbiA9IDAuMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cmF0aW9uO1xufVxuXG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZmluZCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBrZXkgJ2luS2V5JyBhbmQgcmVuYW1lIHRoZW0gJ291dEtleSdcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgQW55IHR5cGUgb2YgaW5wdXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbktleSBUaGUga2V5IG5hbWUgdG8gcmVwbGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IG91dEtleSBUaGUga2V5IG5hbWUgdG8gcmVwbGFjZSBpdCB3aXRoXG4gKi9cbmZ1bmN0aW9uIHJlbmFtZUtleSAoaW5wdXQsIGluS2V5LCBvdXRLZXkpIHtcbiAgaWYgKF8uaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiByZW5hbWVLZXkoaXRlbSwgaW5LZXksIG91dEtleSkpO1xuICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcbiAgICByZXR1cm4gXy5yZWR1Y2UoaW5wdXQsIChyZXN1bHRPYmosIHZhbHVlLCBrZXkpID0+ICh7XG4gICAgICAuLi5yZXN1bHRPYmosXG4gICAgICBba2V5ID09PSBpbktleSA/IG91dEtleSA6IGtleV06IHJlbmFtZUtleSh2YWx1ZSwgaW5LZXksIG91dEtleSksXG4gICAgfSksIHt9KTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn1cblxuZXhwb3J0IHtcbiAgY29uZmlndXJlQXBwLCBkb3dubG9hZEFwcCwgZG93bmxvYWRGaWxlLCBjb3B5TG9jYWxaaXAsIHVuemlwQXBwLCB1bnppcEZpbGUsXG4gIHRlc3RaaXBBcmNoaXZlLCBpc1BhY2thZ2VPckJ1bmRsZSwgZ2V0Q29vcmREZWZhdWx0LCBnZXRTd2lwZVRvdWNoRHVyYXRpb24sXG4gIGNvcHlGcm9tV2luZG93c05ldHdvcmtTaGFyZSwgcmVuYW1lS2V5LFxufTtcbiJdLCJmaWxlIjoibGliL2Jhc2Vkcml2ZXIvaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
