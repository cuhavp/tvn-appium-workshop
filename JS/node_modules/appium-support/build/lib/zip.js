"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toInMemoryZip = toInMemoryZip;
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.default = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _extractZip = _interopRequireDefault(require("extract-zip"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _mkdirp = require("../lib/mkdirp");

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

const extract = _bluebird.default.promisify(_extractZip.default);

const open = _bluebird.default.promisify(_yauzl.default.open);

const ZIP_MAGIC = 'PK';

function extractAllTo(_x, _x2) {
  return _extractAllTo.apply(this, arguments);
}

function _extractAllTo() {
  _extractAllTo = (0, _asyncToGenerator2.default)(function* (zipFilepath, destDir) {
    return yield extract(zipFilepath, {
      dir: destDir
    });
  });
  return _extractAllTo.apply(this, arguments);
}

function _extractEntryTo(_x3, _x4, _x5) {
  return _extractEntryTo2.apply(this, arguments);
}

function _extractEntryTo2() {
  _extractEntryTo2 = (0, _asyncToGenerator2.default)(function* (zipfile, entry, destDir) {
    yield (0, _mkdirp.mkdirp)(_path.default.resolve(destDir, _path.default.dirname(entry.fileName)));
    const writeStream = (0, _fs.createWriteStream)(_path.default.resolve(destDir, entry.fileName), {
      flags: 'w'
    });
    const writeStreamPromise = new _bluebird.default((resolve, reject) => {
      writeStream.once('finish', resolve);
      writeStream.once('error', reject);
    });
    const zipReadStream = yield new _bluebird.default((resolve, reject) => {
      zipfile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
    });
    const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
      zipReadStream.once('end', resolve);
      zipReadStream.once('error', reject);
    });
    zipReadStream.pipe(writeStream);
    return yield _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
  });
  return _extractEntryTo2.apply(this, arguments);
}

function readEntries(_x6, _x7) {
  return _readEntries.apply(this, arguments);
}

function _readEntries() {
  _readEntries = (0, _asyncToGenerator2.default)(function* (zipFilepath, onEntry) {
    const zipfile = yield open(zipFilepath, {
      lazyEntries: true
    });
    const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
      zipfile.once('end', resolve);
      zipfile.once('error', reject);
      zipfile.on('entry', function () {
        var _ref = (0, _asyncToGenerator2.default)(function* (entry) {
          const res = yield onEntry({
            entry,
            extractEntryTo: destDir => _extractEntryTo(zipfile, entry, destDir)
          });

          if (res === false) {
            return zipfile.emit('end');
          }

          zipfile.readEntry();
        });

        return function (_x10) {
          return _ref.apply(this, arguments);
        };
      }());
    });
    zipfile.readEntry();
    return yield zipReadStreamPromise;
  });
  return _readEntries.apply(this, arguments);
}

function toInMemoryZip(_x8) {
  return _toInMemoryZip.apply(this, arguments);
}

function _toInMemoryZip() {
  _toInMemoryZip = (0, _asyncToGenerator2.default)(function* (srcDir) {
    const zipBufferArr = [];
    const zipWriteStream = new _stream.default.Writable({
      write: (buffer, encoding, next) => {
        zipBufferArr.push(buffer);
        next();
      }
    });
    const zipWriteStreamPromise = new _bluebird.default(resolve => {
      zipWriteStream.once('finish', resolve);
    });
    const archive = (0, _archiver.default)('zip', {
      zlib: {
        level: 9
      }
    });
    const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
      archive.once('finish', resolve);
      archive.once('error', errStr => reject(new Error(`Failed to zip directory ${srcDir}: ${errStr}`)));
    });
    archive.directory(srcDir, false);
    archive.pipe(zipWriteStream);
    archive.finalize();
    yield _bluebird.default.all([archiveStreamPromise, zipWriteStreamPromise]);
    return Buffer.concat(zipBufferArr);
  });
  return _toInMemoryZip.apply(this, arguments);
}

function assertValidZip(_x9) {
  return _assertValidZip.apply(this, arguments);
}

function _assertValidZip() {
  _assertValidZip = (0, _asyncToGenerator2.default)(function* (filePath) {
    if (!(yield _fs2.default.exists(filePath))) {
      throw new Error(`The file at '${filePath}' does not exist`);
    }

    const _ref2 = yield _fs2.default.stat(filePath),
          size = _ref2.size;

    if (size < 4) {
      throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
    }

    const fd = yield _fs2.default.open(filePath, 'r');

    try {
      const buffer = Buffer.alloc(ZIP_MAGIC.length);
      yield _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
      const signature = buffer.toString('ascii');

      if (signature !== ZIP_MAGIC) {
        throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
      }

      return true;
    } finally {
      yield _fs2.default.close(fd);
    }
  });
  return _assertValidZip.apply(this, arguments);
}

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip
};
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi96aXAuanMiXSwibmFtZXMiOlsiZXh0cmFjdCIsIkIiLCJwcm9taXNpZnkiLCJub2RlRXh0cmFjdCIsIm9wZW4iLCJ5YXV6bCIsIlpJUF9NQUdJQyIsImV4dHJhY3RBbGxUbyIsInppcEZpbGVwYXRoIiwiZGVzdERpciIsImRpciIsIl9leHRyYWN0RW50cnlUbyIsInppcGZpbGUiLCJlbnRyeSIsInBhdGgiLCJyZXNvbHZlIiwiZGlybmFtZSIsImZpbGVOYW1lIiwid3JpdGVTdHJlYW0iLCJmbGFncyIsIndyaXRlU3RyZWFtUHJvbWlzZSIsInJlamVjdCIsIm9uY2UiLCJ6aXBSZWFkU3RyZWFtIiwib3BlblJlYWRTdHJlYW0iLCJlcnIiLCJyZWFkU3RyZWFtIiwiemlwUmVhZFN0cmVhbVByb21pc2UiLCJwaXBlIiwiYWxsIiwicmVhZEVudHJpZXMiLCJvbkVudHJ5IiwibGF6eUVudHJpZXMiLCJvbiIsInJlcyIsImV4dHJhY3RFbnRyeVRvIiwiZW1pdCIsInJlYWRFbnRyeSIsInRvSW5NZW1vcnlaaXAiLCJzcmNEaXIiLCJ6aXBCdWZmZXJBcnIiLCJ6aXBXcml0ZVN0cmVhbSIsInN0cmVhbSIsIldyaXRhYmxlIiwid3JpdGUiLCJidWZmZXIiLCJlbmNvZGluZyIsIm5leHQiLCJwdXNoIiwiemlwV3JpdGVTdHJlYW1Qcm9taXNlIiwiYXJjaGl2ZSIsInpsaWIiLCJsZXZlbCIsImFyY2hpdmVTdHJlYW1Qcm9taXNlIiwiZXJyU3RyIiwiRXJyb3IiLCJkaXJlY3RvcnkiLCJmaW5hbGl6ZSIsIkJ1ZmZlciIsImNvbmNhdCIsImFzc2VydFZhbGlkWmlwIiwiZmlsZVBhdGgiLCJmcyIsImV4aXN0cyIsInN0YXQiLCJzaXplIiwiZmQiLCJhbGxvYyIsImxlbmd0aCIsInJlYWQiLCJzaWduYXR1cmUiLCJ0b1N0cmluZyIsImNsb3NlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7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QUFDQSxZQUFNRSxTQUFTLEdBQUd6QixNQUFNLENBQUMwQixRQUFQLENBQWdCLE9BQWhCLENBQWxCOztBQUNBLFVBQUlELFNBQVMsS0FBS2hFLFNBQWxCLEVBQTZCO0FBQzNCLGNBQU0sSUFBSWlELEtBQUosQ0FBVyx1QkFBc0JlLFNBQVUsU0FBUVQsUUFBUyxJQUFsRCxHQUNiLHVEQUFzRHZELFNBQVUsR0FEN0QsQ0FBTjtBQUVEOztBQUNELGFBQU8sSUFBUDtBQUNELEtBVEQsU0FTVTtBQUNSLFlBQU13RCxhQUFHVSxLQUFILENBQVNOLEVBQVQsQ0FBTjtBQUNEO0FBQ0YsRzs7OztlQUdjO0FBQUUzRCxFQUFBQSxZQUFGO0FBQWdCdUIsRUFBQUEsV0FBaEI7QUFBNkJRLEVBQUFBLGFBQTdCO0FBQTRDc0IsRUFBQUE7QUFBNUMsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCBub2RlRXh0cmFjdCBmcm9tICdleHRyYWN0LXppcCc7XG5pbXBvcnQgeWF1emwgZnJvbSAneWF1emwnO1xuaW1wb3J0IGFyY2hpdmVyIGZyb20gJ2FyY2hpdmVyJztcbmltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBta2RpcnAgfSBmcm9tICcuLi9saWIvbWtkaXJwJztcbmltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBmcyBmcm9tICcuL2ZzJztcblxuY29uc3QgZXh0cmFjdCA9IEIucHJvbWlzaWZ5KG5vZGVFeHRyYWN0KTtcbmNvbnN0IG9wZW4gPSBCLnByb21pc2lmeSh5YXV6bC5vcGVuKTtcbmNvbnN0IFpJUF9NQUdJQyA9ICdQSyc7XG5cbi8qKlxuICogRXh0cmFjdCB6aXBmaWxlIHRvIGEgZGlyZWN0b3J5XG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZXBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0RGlyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBbGxUbyAoemlwRmlsZXBhdGgsIGRlc3REaXIpIHtcbiAgcmV0dXJuIGF3YWl0IGV4dHJhY3QoemlwRmlsZXBhdGgsIHtkaXI6IGRlc3REaXJ9KTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgc2luZ2xlIHppcCBlbnRyeSB0byBhIGRpcmVjdG9yeVxuICogQHBhcmFtIHtTdHJlYW1hYmxlfSB6aXBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gZW50cnlcbiAqIEBwYXJhbSB7c3RyfSBkZXN0RGlyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9leHRyYWN0RW50cnlUbyAoemlwZmlsZSwgZW50cnksIGRlc3REaXIpIHtcblxuICAvLyBDcmVhdGUgZGVzdCBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdCBhbHJlYWR5XG4gIGF3YWl0IG1rZGlycChwYXRoLnJlc29sdmUoZGVzdERpciwgcGF0aC5kaXJuYW1lKGVudHJ5LmZpbGVOYW1lKSkpO1xuXG4gIC8vIENyZWF0ZSBhIHdyaXRlIHN0cmVhbVxuICBjb25zdCB3cml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtKHBhdGgucmVzb2x2ZShkZXN0RGlyLCBlbnRyeS5maWxlTmFtZSksIHtmbGFnczogJ3cnfSk7XG4gIGNvbnN0IHdyaXRlU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cml0ZVN0cmVhbS5vbmNlKCdmaW5pc2gnLCByZXNvbHZlKTtcbiAgICB3cml0ZVN0cmVhbS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB6aXBSZWFkU3RyZWFtIGFuZCBwaXBlIGRhdGEgdG8gdGhlIHdyaXRlIHN0cmVhbVxuICAvLyAoZm9yIHNvbWUgb2RkIHJlYXNvbiBCLnByb21pc2lmeSBkb2Vzbid0IHdvcmsgb24gemlwZmlsZS5vcGVuUmVhZFN0cmVhbSwgaXQgY2F1c2VzIGFuIGVycm9yICdjbG9zZWQnKVxuICBjb25zdCB6aXBSZWFkU3RyZWFtID0gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcGZpbGUub3BlblJlYWRTdHJlYW0oZW50cnksIChlcnIsIHJlYWRTdHJlYW0pID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZWFkU3RyZWFtKSk7XG4gIH0pO1xuICBjb25zdCB6aXBSZWFkU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBSZWFkU3RyZWFtLm9uY2UoJ2VuZCcsIHJlc29sdmUpO1xuICAgIHppcFJlYWRTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcbiAgemlwUmVhZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcblxuICAvLyBXYWl0IGZvciB0aGUgemlwUmVhZFN0cmVhbSBhbmQgd3JpdGVTdHJlYW0gdG8gZW5kIGJlZm9yZSByZXR1cm5pbmdcbiAgcmV0dXJuIGF3YWl0IEIuYWxsKFtcbiAgICB6aXBSZWFkU3RyZWFtUHJvbWlzZSxcbiAgICB3cml0ZVN0cmVhbVByb21pc2UsXG4gIF0pO1xufVxuXG4vKipcbiAqIEdldCBlbnRyaWVzIGZvciBhIHppcCBmb2xkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNEaXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRW50cnkgQ2FsbGJhY2sgd2hlbiBlbnRyeSBpcyByZWFkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkVycm9yIENhbGxiYWNrIHdoZW4gZXJyb3Igb2NjdXJzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRFbnRyaWVzICh6aXBGaWxlcGF0aCwgb25FbnRyeSkge1xuXG4gIC8vIE9wZW4gYSB6aXAgZmlsZSBhbmQgc3RhcnQgcmVhZGluZyBlbnRyaWVzXG4gIGNvbnN0IHppcGZpbGUgPSBhd2FpdCBvcGVuKHppcEZpbGVwYXRoLCB7bGF6eUVudHJpZXM6IHRydWV9KTtcbiAgY29uc3QgemlwUmVhZFN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwZmlsZS5vbmNlKCdlbmQnLCByZXNvbHZlKTtcbiAgICB6aXBmaWxlLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcblxuICAgIC8vIE9uIGVhY2ggZW50cnksIGNhbGwgJ29uRW50cnknIGFuZCB0aGVuIHJlYWQgdGhlIG5leHQgZW50cnlcbiAgICB6aXBmaWxlLm9uKCdlbnRyeScsIGFzeW5jIChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgb25FbnRyeSh7ZW50cnksIGV4dHJhY3RFbnRyeVRvOiAoZGVzdERpcikgPT4gX2V4dHJhY3RFbnRyeVRvKHppcGZpbGUsIGVudHJ5LCBkZXN0RGlyKX0pO1xuICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHppcGZpbGUuZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xuICAgIH0pO1xuICB9KTtcbiAgemlwZmlsZS5yZWFkRW50cnkoKTtcblxuICAvLyBXYWl0IGZvciB0aGUgZW50cmllcyB0byBmaW5pc2ggYmVpbmcgaXRlcmF0ZWQgdGhyb3VnaFxuICByZXR1cm4gYXdhaXQgemlwUmVhZFN0cmVhbVByb21pc2U7XG59XG5cbi8qKlxuICogQ29udmVydHMgY29udGVudHMgb2YgbG9jYWwgZGlyZWN0b3J5IHRvIGFuIGluLW1lbW9yeSAuemlwIGJ1ZmZlclxuICogQHBhcmFtIHsqfSBzcmNEaXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9Jbk1lbW9yeVppcCAoc3JjRGlyKSB7XG4gIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IHppcCBidWZmZXJzIHdpbGwgYmUgc3RyZWFtZWQgdG9cbiAgY29uc3QgemlwQnVmZmVyQXJyID0gW107XG4gIGNvbnN0IHppcFdyaXRlU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSh7XG4gICAgd3JpdGU6IChidWZmZXIsIGVuY29kaW5nLCBuZXh0KSA9PiB7XG4gICAgICB6aXBCdWZmZXJBcnIucHVzaChidWZmZXIpO1xuICAgICAgbmV4dCgpO1xuICAgIH0sXG4gIH0pO1xuICBjb25zdCB6aXBXcml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSkgPT4ge1xuICAgIC8vIERvbid0IG5lZWQgdG8gZG8gZXJyb3IgaGFuZGxpbmcgc2luY2UgdGhpcyB3cml0ZVN0cmVhbSBpcyBpbi1tZW1vcnkgYW5kIGRvZXNuJ3QgZW1pdCBhbnkgZXJyb3JzXG4gICAgemlwV3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gIH0pO1xuXG4gIC8vIFppcCAnc3JjRGlyJyBhbmQgc3RyZWFtIGl0IHRvIHRoZSBhYm92ZSB3cml0YWJsZSBzdHJlYW1cbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7XG4gICAgemxpYjoge2xldmVsOiA5fVxuICB9KTtcbiAgY29uc3QgYXJjaGl2ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXJjaGl2ZS5vbmNlKCdmaW5pc2gnLCByZXNvbHZlKTtcbiAgICBhcmNoaXZlLm9uY2UoJ2Vycm9yJywgKGVyclN0cikgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIHppcCBkaXJlY3RvcnkgJHtzcmNEaXJ9OiAke2VyclN0cn1gKSkpO1xuICB9KTtcbiAgYXJjaGl2ZS5kaXJlY3Rvcnkoc3JjRGlyLCBmYWxzZSk7XG4gIGFyY2hpdmUucGlwZSh6aXBXcml0ZVN0cmVhbSk7XG4gIGFyY2hpdmUuZmluYWxpemUoKTtcblxuICAvLyBXYWl0IGZvciB0aGUgc3RyZWFtcyB0byBmaW5pc2hcbiAgYXdhaXQgQi5hbGwoW2FyY2hpdmVTdHJlYW1Qcm9taXNlLCB6aXBXcml0ZVN0cmVhbVByb21pc2VdKTtcblxuICAvLyBSZXR1cm4gdGhlIGFycmF5IG9mIHppcCBidWZmZXJzIGNvbmNhdGVuYXRlZCBpbnRvIG9uZSBidWZmZXJcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoemlwQnVmZmVyQXJyKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB3aGV0aGVyIHRoZSBnaXZlbiBmaWxlIGlzIGEgdmFsaWQgWklQIGFyY2hpdmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggLSBGdWxsIHBhdGggdG8gdGhlIGZpbGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICovXG5hc3luYyBmdW5jdGlvbiBhc3NlcnRWYWxpZFppcCAoZmlsZVBhdGgpIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cblxuICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGZpbGVQYXRoKTtcbiAgaWYgKHNpemUgPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGlzIHRvbyBzbWFsbCB0byBiZSBhIFpJUCBhcmNoaXZlYCk7XG4gIH1cbiAgY29uc3QgZmQgPSBhd2FpdCBmcy5vcGVuKGZpbGVQYXRoLCAncicpO1xuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhaSVBfTUFHSUMubGVuZ3RoKTtcbiAgICBhd2FpdCBmcy5yZWFkKGZkLCBidWZmZXIsIDAsIFpJUF9NQUdJQy5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJ1ZmZlci50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoc2lnbmF0dXJlICE9PSBaSVBfTUFHSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpbGUgc2lnbmF0dXJlICcke3NpZ25hdHVyZX0nIG9mICcke2ZpbGVQYXRofScgYCArXG4gICAgICAgIGBpcyBub3QgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIFpJUCBhcmNoaXZlIHNpZ25hdHVyZSAnJHtaSVBfTUFHSUN9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5jbG9zZShmZCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZXh0cmFjdEFsbFRvLCByZWFkRW50cmllcywgdG9Jbk1lbW9yeVppcCwgX2V4dHJhY3RFbnRyeVRvLCBhc3NlcnRWYWxpZFppcCB9O1xuZXhwb3J0IGRlZmF1bHQgeyBleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBhc3NlcnRWYWxpZFppcCB9O1xuIl0sImZpbGUiOiJsaWIvemlwLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
